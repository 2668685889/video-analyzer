# 文件夹监控持续性问题修复说明

## 问题描述

用户反映文件夹监控功能存在以下问题：
- 监控功能只能在应用程序启动时工作一次
- 在检测到第一个新文件后，后续添加的文件无法被监控到
- 监控功能失效，需要重启应用程序才能恢复

## 问题分析

通过代码分析，发现问题的根本原因在于 `VideoFileHandler` 类中的文件去重机制：

### 原始问题代码
```python
class VideoFileHandler(FileSystemEventHandler):
    def __init__(self, callback: Callable[[str], None]):
        super().__init__()
        self.callback = callback
        self.supported_formats = config.get_supported_formats()
        self.processed_files = set()  # 问题所在：永久记录已处理文件
        
    def on_created(self, event):
        if not event.is_directory and self.is_video_file(event.src_path):
            if event.src_path not in self.processed_files:
                self.processed_files.add(event.src_path)  # 文件被永久标记为已处理
                self.callback(event.src_path)
```

### 问题原因
1. **永久文件记录**：`processed_files` 集合会永久记录已处理的文件路径
2. **无法重复处理**：一旦文件被处理过，即使删除后重新添加，也不会再次触发回调
3. **缺乏状态检查**：没有检查 Observer 对象的健康状态
4. **无自动恢复**：当 Observer 异常停止时，无法自动恢复

## 修复方案

### 1. 改进文件去重机制

将永久文件记录改为基于时间的去重机制：

```python
class VideoFileHandler(FileSystemEventHandler):
    def __init__(self, callback: Callable[[str], None]):
        super().__init__()
        self.callback = callback
        self.supported_formats = config.get_supported_formats()
        self.recent_files = {}  # 记录最近处理的文件及其时间戳
        self.duplicate_threshold = 5  # 5秒内的重复文件事件将被忽略
```

### 2. 添加重复事件检测方法

```python
def _is_duplicate_event(self, file_path: str) -> bool:
    """
    检查是否为重复事件，基于时间阈值
    """
    current_time = time.time()
    
    # 清理过期的记录
    expired_files = []
    for path, timestamp in self.recent_files.items():
        if current_time - timestamp > self.duplicate_threshold * 2:
            expired_files.append(path)
    
    for path in expired_files:
        del self.recent_files[path]
    
    # 检查是否为重复事件
    if file_path in self.recent_files:
        time_diff = current_time - self.recent_files[file_path]
        if time_diff < self.duplicate_threshold:
            return True  # 是重复事件
    
    return False  # 不是重复事件
```

### 3. 增强监控器健康检查

```python
def start_monitoring(self) -> bool:
    if self.is_monitoring:
        # 检查Observer是否还在运行
        if self.observer and self.observer.is_alive():
            return True
        else:
            # Observer已停止，需要重新启动
            self.is_monitoring = False
            if self.status_callback:
                self.status_callback("检测到监控器异常停止，正在重新启动...")
```

### 4. 添加自动恢复机制

```python
def check_health(self) -> bool:
    """
    检查监控器健康状态并尝试自动恢复
    """
    if not self.is_monitoring:
        return False
        
    # 检查Observer状态
    if not self.observer or not self.observer.is_alive():
        if self.status_callback:
            self.status_callback("检测到监控器异常，尝试自动恢复...")
        
        # 尝试重新启动
        self.is_monitoring = False
        return self.start_monitoring()
        
    return True
```

## 修复位置

**文件**: `src/utils/folder_monitor.py`

**主要修改**:
1. `VideoFileHandler.__init__()` - 改进初始化逻辑
2. `VideoFileHandler.on_created()` - 添加重复事件检测
3. `VideoFileHandler.on_moved()` - 添加重复事件检测
4. `VideoFileHandler._is_duplicate_event()` - 新增方法
5. `FolderMonitor.start_monitoring()` - 增强启动逻辑
6. `FolderMonitor.is_running()` - 改进状态检测
7. `FolderMonitor.check_health()` - 新增健康检查方法

## 修复效果

### 解决的问题
1. **持续监控**：文件夹监控现在可以持续工作，不会在处理第一个文件后失效
2. **重复处理**：同一文件路径可以在不同时间被重复处理（避免5秒内的重复事件）
3. **自动恢复**：当监控器异常停止时，会自动尝试重新启动
4. **状态检测**：提供更准确的监控状态检测
5. **内存管理**：自动清理过期的文件记录，避免内存泄漏

### 技术改进
1. **时间基础去重**：使用时间戳而非永久集合来避免重复处理
2. **健康监控**：定期检查 Observer 对象的运行状态
3. **异常处理**：增强错误处理和状态同步
4. **资源管理**：确保 Observer 对象的正确启动和停止

## 测试验证

修复后的监控功能应该能够：
1. 持续监控指定文件夹中的新文件
2. 正确处理文件的创建和移动事件
3. 在监控器异常时自动恢复
4. 避免短时间内的重复事件处理
5. 提供准确的监控状态反馈

## 相关文件

- `src/utils/folder_monitor.py` - 文件夹监控核心实现
- `src/ui/main_window.py` - 监控功能的UI集成

## 注意事项

1. **时间阈值**：当前设置为5秒的重复事件阈值，可根据需要调整
2. **内存清理**：系统会自动清理超过10秒的文件记录
3. **异常恢复**：监控器会在检测到异常时自动尝试重启
4. **状态同步**：UI状态会实时反映监控器的真实状态

通过这些修复，文件夹监控功能现在可以稳定、持续地工作，为用户提供可靠的自动文件检测服务。