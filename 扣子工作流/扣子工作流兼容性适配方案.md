# 扣子工作流兼容性适配方案

## 问题分析

根据您的反馈，`input_format_adapter.py` 代码在本地测试正常，但在扣子工作流中无法输出结果。经过深入分析，发现了以下关键差异：

### 1. 扣子工作流代码块的特殊要求

<mcreference link="https://blog.csdn.net/xx_nm98/article/details/141199645" index="1">1</mcreference> 扣子工作流中的代码块有以下特殊要求：

- **输入获取方式**：必须通过 `args.params` 获取输入参数
- **返回值格式**：必须返回字典格式，且字典的键值对应输出字段
- **字段类型匹配**：输出字段的类型必须与代码中定义的类型严格匹配

### 2. 本地环境与扣子环境的差异

| 环境差异 | 本地Python环境 | 扣子工作流环境 |
|---------|---------------|---------------|
| 输入方式 | 直接函数调用 | 通过 `args.params` 获取 |
| 返回格式 | 任意格式 | 必须是字典格式 |
| 字段类型 | 灵活处理 | 严格类型匹配 |
| 执行环境 | 完整Python环境 | 受限的沙箱环境 |

## 适配方案

### 方案一：创建扣子工作流专用适配器

创建一个专门用于扣子工作流的适配器函数：

```python
def coze_workflow_adapter():
    """
    扣子工作流专用适配器
    """
    # 1. 从扣子工作流获取输入
    params = args.params
    input_data = params.get('input', '')
    
    # 2. 调用原有的处理逻辑
    from input_format_adapter import InputFormatAdapter
    
    adapter = InputFormatAdapter()
    result = adapter.process_input(input_data)
    
    # 3. 确保返回字典格式，且字段类型正确
    ret = {
        'video_serial_number': str(result.get('video_serial_number', '')),
        'video_content_summary': str(result.get('video_content_summary', '')),
        'detailed_content_description': str(result.get('detailed_content_description', '')),
        'keyword_tags': str(result.get('keyword_tags', '')),
        'main_objects': str(result.get('main_objects', '')),
        'status': str(result.get('status', 'success')),
        'message': str(result.get('message', '数据处理成功'))
    }
    
    return ret
```

### 方案二：修改现有代码以兼容扣子环境

在 `input_format_adapter.py` 中添加扣子工作流检测和适配：

```python
def detect_coze_environment():
    """
    检测是否在扣子工作流环境中运行
    """
    try:
        # 尝试访问扣子工作流特有的 args 对象
        return 'args' in globals() and hasattr(args, 'params')
    except:
        return False

def main(input_data=None):
    """
    主函数 - 兼容本地和扣子工作流环境
    """
    # 检测运行环境
    if detect_coze_environment():
        # 扣子工作流环境
        params = args.params
        input_data = params.get('input', '')
        
        # 处理数据
        adapter = InputFormatAdapter()
        result = adapter.process_input(input_data)
        
        # 返回扣子工作流要求的字典格式
        return {
            'video_serial_number': str(result.get('video_serial_number', '')),
            'video_content_summary': str(result.get('video_content_summary', '')),
            'detailed_content_description': str(result.get('detailed_content_description', '')),
            'keyword_tags': str(result.get('keyword_tags', '')),
            'main_objects': str(result.get('main_objects', '')),
            'status': str(result.get('status', 'success')),
            'message': str(result.get('message', '数据处理成功'))
        }
    else:
        # 本地环境 - 保持原有逻辑
        if input_data is None:
            # 演示模式
            demo()
            return
        
        adapter = InputFormatAdapter()
        return adapter.process_input(input_data)
```

### 方案三：简化的扣子工作流代码块

直接在扣子工作流的代码块中编写简化版本：

```python
# 扣子工作流代码块内容
params = args.params
input_data = params.get('input', '')

# 简化的字段映射逻辑
field_mapping = {
    'video_serial_number': ['视频编号', 'video_serial_number', '编号'],
    'video_content_summary': ['视频内容概要', 'video_content_summary', '内容概要'],
    'detailed_content_description': ['详细内容描述', 'detailed_content_description', '详细描述'],
    'keyword_tags': ['关键词标签', 'keyword_tags', '标签'],
    'main_objects': ['主要对象', 'main_objects', '对象']
}

# 处理输入数据
import json
import re

def extract_fields(data_str):
    result = {}
    
    # 尝试解析JSON
    try:
        if isinstance(data_str, str):
            # 清理JSON字符串
            cleaned = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', data_str)
            data = json.loads(cleaned)
        else:
            data = data_str
            
        # 字段映射
        for target_field, possible_keys in field_mapping.items():
            for key in possible_keys:
                if key in data:
                    result[target_field] = str(data[key])
                    break
            if target_field not in result:
                result[target_field] = ''
                
    except Exception as e:
        # 如果JSON解析失败，返回空字段
        for target_field in field_mapping.keys():
            result[target_field] = ''
    
    return result

# 处理数据
result = extract_fields(input_data)

# 返回扣子工作流要求的字典格式
ret = {
    'video_serial_number': result.get('video_serial_number', ''),
    'video_content_summary': result.get('video_content_summary', ''),
    'detailed_content_description': result.get('detailed_content_description', ''),
    'keyword_tags': result.get('keyword_tags', ''),
    'main_objects': result.get('main_objects', ''),
    'status': 'success',
    'message': '数据处理成功'
}
```

## 关键注意事项

### 1. 字段类型要求
<mcreference link="https://blog.csdn.net/xx_nm98/article/details/141199645" index="1">1</mcreference> 在扣子工作流中，输出字段的类型必须与代码中定义的类型严格匹配，否则会报错。建议所有输出字段都使用字符串类型。

### 2. 返回值格式
扣子工作流要求代码块必须返回字典格式，字典的键对应输出字段名。

### 3. 输入获取方式
在扣子工作流中，必须通过 `params = args.params` 的方式获取输入参数。

### 4. 错误处理
扣子工作流环境对错误比较敏感，建议添加充分的异常处理。

## 推荐实施步骤

1. **立即解决方案**：使用方案三，直接在扣子工作流代码块中编写简化版本
2. **长期方案**：使用方案二，修改现有代码以兼容两种环境
3. **测试验证**：在扣子工作流中测试各个字段的输出
4. **优化调试**：根据实际运行结果进行调整

## 调试建议

在扣子工作流代码块中添加调试输出：

```python
# 调试输出
ret['debug_input'] = str(input_data)[:100]  # 输入数据的前100个字符
ret['debug_type'] = str(type(input_data))   # 输入数据类型
ret['debug_length'] = str(len(str(input_data)))  # 输入数据长度
```

这样可以帮助您了解扣子工作流实际接收到的数据格式和内容。